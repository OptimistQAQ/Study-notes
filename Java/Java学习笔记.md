# Java学习笔记



## 1 sleep是线程类(Thread)的方法，导致此线程暂停执行指定时间，给执行机会给其他线程，但是监控状态，到时候会自动恢复。调用sleep不会释放对象锁。wait 是 Object 类的方法，对此对象调用 wait方法导致本线程放弃对象锁，进入等待此对象的等待对象池中，只有针对此对象发出 notify() 方法(或者 notify all)后本线程才进入对象锁定池准备获得对象锁进入运行状态。



### 2  sleep： 导致此线程暂停执行指定时间 

###     stop：   这个方法将终止所有未结束的方法，包括run   

###     syn chronized： 对象锁  

###     yield：  当前正在被服务的线程可能觉得 CPU的服务质量不好，于是提前退出   

###     wait：  当前正在被服务的线程需要睡一会，醒来后继续被服务



##  3： 在类方法中不能使用this关键字，在类方法中可以调用其他类中的方法，在类方法中可以通过实例化对象调用实例方法



##  4  DOS命令基本操作 

##  	ping命令：利用它能够检查网络是否连通，(ping -a + IP地址) 

##  	ipconfig -all :  用于显示或设置网络设备  

##  	nestat ： 用于查看基于NETBIOS 的 TCP/IP连接状态 

##  	telnet  ：访问远程计算机

## 5：Java基础语法

1.  基本数据类型：byte、int、long、short、float、double、char、boolean 
2.  逻辑运算符： &、|、^、&&、||
  在这里介绍一下异或(^)：和或有点不一样  
  两边结果一样就为false
  两边结果不一样为true
  
3.  位运算符： <<   >>   >>>(无符号右移)

  练习————高效的计算出2*8
  
     2*8 = 2<<3;  //将2左移三位即为2*8 = 16；
     
4.  重载的定义：

  在同一个类中，如果出现了两个或两个以上的同名函数，只要他们的参数个数或者参数类型不同，就可以称之为函数重载了。
  
  
####  如何区分重载和重写
  
  
    ** 重载 **：当函数同名时，只看它们参数列表，和他们的返回值没有关系！
    
    
    ** 重写 **：父类与子类之间的多态性，对父类函数的重新定义。如果子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写，返回值必须是父类的类型或者是子类的类型
    
 ####  5.  Java内存管理
 
  Java与C++之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。
  
   ####  对于从事C和C++程序开发的开发人员来说，在内存管理领域，他们既是拥有最高权力的皇帝，又是从事最基础工作的劳动人民—既拥有每一个对象的"所有权"，又担负着每一个对象生命开始到终结的维护责任。
   ####  对于Java程序员来说，在虚拟机的自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，而且不容易出现内存泄漏和内存溢出问题，看起来由虚拟机管理内存一切都很美好。不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那排查错误将会成为一项异常艰难的工作。

#### 6.构造函数：


    1. 该函数的名称和所在的类的名称相同
    
    2. 不需要定义返回值类型
    
    3. 该函数没有具体的返回值
    
    4. Attention： 所有对象创建时都需要初始化才能使用。
    
    5. 注意事项：一个类在定义时如果没有定义过构造函数，那么该类会自动生成一个空参数的构造函数，为了方便该类创建对象，完成初始化。如果该类自定义了构造函数，那么默认的构造函数就没有了。
    
    6. 一个类中，可以有多个构造函数，因为它们的函数名称都相同，所以只能通过参数列表来区分。所以，一个类中如果出现多个构造函数。它们的存在是以重载体现的。


####  7.创建一个对象在内存中都做了什么？

    Person p = new Person();
    1.先将硬盘上指定位置的Person.class文件加载内存。
    2.执行main方法时，在栈内存中开辟了main方法的空间(压栈——> 进栈)，然后再main方法的栈区分配了一个变量p 
    3.在堆内存中开辟一个实体空间，分配了一个内存的首地址值。new
    4.在实体空间进行属性的空间分配，并进行默认初始化。
    5.对空间的属性进行显示初始化。
    6.进行实体的构造代码块初始化。
    7.调用该实体对应的构造函数，进行构造函数初始化。
    8.将首地址赋值给p，p变量就引用了该实体。
    
    
####  8.静态方法

    <  静态方法可以通过类名调用，任何的实例也都可以调用，因此静态方法中不能使用this和super关键字，不能直接访问所属类的实例变量和实例方法
    (就是不带static的成员变量和成员方法)，只能访问所属类的静态成员变量和成员方法。因此实例成员和特定的对象关联！
    

#### 9. 抽象类和接口的区别

    1.  抽象类只能被继承，而且只能被单继承；接口需要被实现，而且可以多实现。
    2.  抽象类可以定义非抽象方法，子类可以直接使用；接口中都是抽象方法，需要子类去实现。
    3.  抽象类使用的是is a关系；接口是like a关系。
    4.  抽象类的成员修饰符可以自定义；接口中必须是public。
    
#### 10. 1多线程


    1.  线程的名称是由Thread-编号定义的，从0开始。
    2.  线程要运行的方法统一都存在了run方法中。
    3.  start()方法； 用start方法来启动线程，真正实现了多线程运行，这无需等待run方法体执行完毕而直接继续执行下面的代码，
        通过调用Thread类中的start方法来启动线程，这样线程就处于就续状态，并没有运行，一旦CPU得到时间片，就开始执行run方法，
        这里run() 方法称为线程体，它包含了这个线程体要执行的内容。run()方法运行结束，此线程随即终止。
    4.  run()方法只是一个类的普通方法而已，如果直接调用run()方法，程序中依然只有主线这一个线程，其程序执行的路径还是只有一条，
        没有达到写线程的目的。

